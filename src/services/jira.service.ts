/**
 * Jira Integration Service - lightweight stub implementation
 */

import {
  JiraBulkExportRequest,
  JiraBulkExportResponse,
  JiraConnectionSettings,
  JiraExportRequest,
  JiraExportResponse,
  JiraImportRequest,
  JiraSyncStatus,
  JiraWebhookPayload,
} from '../models/jira.model';
import { Requirement } from '../models/requirement.model';

interface JiraLinkRecord {
  requirementId: string;
  jiraKey: string;
  jiraId: string;
  lastSyncedAt: Date;
}

export class JiraService {
  private settings: JiraConnectionSettings | null = null;
  private linkStore = new Map<string, JiraLinkRecord>();

  constructor() {
    void this.loadSettings();
  }

  /**
   * Load Jira settings from environment variables.
   */
  private async loadSettings(): Promise<void> {
    const baseUrl = process.env['JIRA_BASE_URL'] || '';
    const email = process.env['JIRA_EMAIL'] || '';
    const apiToken = process.env['JIRA_API_TOKEN'] || '';
    const cloudId = process.env['JIRA_CLOUD_ID'];

    const baseSettings: JiraConnectionSettings = {
      baseUrl,
      email,
      apiToken,
      projects: [],
      syncEnabled: false,
      syncInterval: 30,
    };

    this.settings = cloudId ? { ...baseSettings, cloudId } : baseSettings;
  }

  /**
   * Export a requirement to Jira (stubbed).
   */
  async exportToJira(request: JiraExportRequest): Promise<JiraExportResponse> {
    if (!this.settings || !this.settings.baseUrl || !this.settings.email || !this.settings.apiToken) {
      return {
        success: false,
        error: 'Jira integration is not configured. Please provide JIRA_BASE_URL, JIRA_EMAIL, and JIRA_API_TOKEN.',
      };
    }

    const jiraKey = `${request.projectKey}-${Math.floor(Math.random() * 9000) + 1000}`;
    const jiraId = `jira-${Date.now()}`;
    const linkRecord: JiraLinkRecord = {
      requirementId: request.requirementId,
      jiraKey,
      jiraId,
      lastSyncedAt: new Date(),
    };
    this.linkStore.set(request.requirementId, linkRecord);

    return {
      success: true,
      jiraKey,
      jiraId,
      jiraUrl: `${this.settings.baseUrl}/browse/${jiraKey}`,
      linkedRequirementId: request.requirementId,
    };
  }

  /**
   * Bulk export requirements to Jira (stubbed).
   */
  async bulkExportToJira(request: JiraBulkExportRequest): Promise<JiraBulkExportResponse> {
    const results: JiraBulkExportResponse['results'] = [];
    let successCount = 0;

    for (const requirementId of request.requirementIds) {
      const exportRequest: JiraExportRequest = {
        requirementId,
        projectKey: request.projectKey,
        issueType: request.issueType,
        linkBack: request.linkBack,
      };

      if (request.fieldMappings) {
        exportRequest.fieldMappings = request.fieldMappings;
      }

      const exportResult = await this.exportToJira(exportRequest);

      if (exportResult.success) {
        successCount += 1;
        const entry: JiraBulkExportResponse['results'][number] = {
          requirementId,
          success: true,
        };
        if (exportResult.jiraKey) {
          entry.jiraKey = exportResult.jiraKey;
        }
        results.push(entry);
      } else {
        const entry: JiraBulkExportResponse['results'][number] = {
          requirementId,
          success: false,
        };
        if (exportResult.error) {
          entry.error = exportResult.error;
        }
        results.push(entry);
      }
    }

    return {
      totalRequirements: request.requirementIds.length,
      successCount,
      failureCount: request.requirementIds.length - successCount,
      results,
    };
  }

  /**
   * Import a Jira issue as a requirement (stubbed).
   */
  async importFromJira(request: JiraImportRequest): Promise<Requirement | null> {
    const now = new Date();
    const requirement: Requirement = {
      id: `REQ-${now.getTime()}`,
      title: `Imported requirement from ${request.jiraKey}`,
      description: 'This requirement was generated by the Jira stub integration.',
      status: 'draft',
      priority: 'medium',
      createdBy: 'system',
      createdAt: now,
      updatedAt: now,
      completionPercentage: 0,
      tags: [],
      metadata: {
        jiraKey: request.jiraKey,
        importedFrom: 'jira',
        importedAt: now.toISOString(),
      },
    };

    const jiraKey = request.jiraKey;
    const jiraId = `jira-${now.getTime()}`;
    this.linkStore.set(requirement.id, {
      requirementId: requirement.id,
      jiraKey,
      jiraId,
      lastSyncedAt: now,
    });

    return requirement;
  }

  /**
   * Sync requirement with Jira (stubbed).
   */
  async syncWithJira(requirementId: string): Promise<JiraSyncStatus> {
    const link = this.linkStore.get(requirementId);

    if (!link) {
      return {
        requirementId,
        jiraKey: '',
        lastSyncedAt: new Date(),
        syncDirection: 'bidirectional',
        status: 'error',
        conflictDetails: ['No Jira link configured for this requirement'],
      };
    }

    const lastSyncedAt = new Date();
    this.linkStore.set(requirementId, { ...link, lastSyncedAt });

    return {
      requirementId,
      jiraKey: link.jiraKey,
      lastSyncedAt,
      syncDirection: 'bidirectional',
      status: 'synced',
    };
  }

  /**
   * Handle Jira webhook events (stubbed).
   */
  async handleWebhook(payload: JiraWebhookPayload): Promise<void> {
    const jiraKey = payload.issue?.key;
    if (!jiraKey) {
      return;
    }

    const link = this.findLinkByJiraKey(jiraKey);
    if (!link) {
      return;
    }

    this.linkStore.set(link.requirementId, { ...link, lastSyncedAt: new Date() });
  }

  private findLinkByJiraKey(jiraKey: string): JiraLinkRecord | undefined {
    for (const record of this.linkStore.values()) {
      if (record.jiraKey === jiraKey) {
        return record;
      }
    }
    return undefined;
  }
}

export const jiraService = new JiraService();
export default JiraService;
